% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dendromap2.R
\name{dendromap2}
\alias{dendromap2}
\title{dendromap - find cophylogenetic patterns in a dataset}
\usage{
dendromap2(X, row.tree, col.tree, ncores = NULL, max_Pval = 0.01,
  nP = 100, W = NULL, V = NULL, n_sim = NULL,
  estimate_runtime = FALSE, discard_contingency_zeros = FALSE)
}
\arguments{
\item{X}{matrix whose rownames are in \code{row.tree$tip.label} and colnames are in \code{col.tree$tip.label}}

\item{row.tree}{phylo class object. Polytomies will be ignored.}

\item{col.tree}{phylo class object. Polytomies will be ignored.}

\item{ncores}{If not NULL, then integer specifying number of cores to use for parallelizable steps}

\item{max_Pval}{maximum P-value for consideration - will scan all P<max_Pval for optimal lineage.}

\item{nP}{maximum number of P-values between the minimum observed P-value and the \code{max_Pval} specified to scan.}

\item{W}{optional \code{treeBasis(row.tree)} - must have colnames in the format of e.g. "node_51" for node 51.}

\item{V}{optional \code{treeBasis(col.tree)} - must have colnames in the format of e.g. "node_51" for node 51.}

\item{n_sim}{optional number of null datasets to simulate (via row & column shuffling) in order to generate approximate P-values in \code{\link{makeRCtable}}}

\item{estimate_runtime}{logical - do you want to estimate the runtime for the second half of the algorithm (scanning F-statistics across P-value thresholds)?}

\item{discard_contingency_zeros}{logical - do you want to discard incomparable rc node pairs?}
}
\description{
dendromap - find cophylogenetic patterns in a dataset
}
\examples{
library(dendromap)
set.seed(3)
m=1e3
n=30
row.tree <- rtree(m) \%>\% phytools::force.ultrametric()
col.tree <- rtree(n)
S <- treeSim(5,row.tree,col.tree,row.depth.min=2,row.depth.max=3,col.node=n+1,fix.col.node=T) 
eta <- S$W \%*\% (10*sign(S$D)) \%*\% t(S$V)
X <- eta+matrix(rnorm(m*n),nrow=m)
clrinv <- function(x) exp(x)/sum(exp(x))
rmlt <- function(p,lambda=5e3) rmultinom(1,rpois(1,lambda),prob = p)
N <- apply(X,2,clrinv) \%>\% apply(2,rmlt)
rownames(N) <- row.tree$tip.label
colnames(N) <- col.tree$tip.label
dm <- dendromap(N,row.tree,col.tree,Pval_threshold=0.05)
## can use multiple cores for parallelization. Will speed-up large datasets.
## big graphs have to be handled with an alternative max_clique algorithm: max_clique_SA
## dm2 <- dendromap(N,row.tree,col.tree,W=S$W,V=S$V,ncores=2,Pval_threshold=0.2)
#Since they've already been computed, inputting the matrices W, V saves time.

dendromap:::print.dendromap(S)
dendromap:::print.dendromap(dm)

dendromap:::plot.dendromap(S)
dendromap:::plot.dendromap(dm)

S$Lineages[,rc:=paste(row.node,col.node,sep='_')]
dm$Lineages[,rc:=paste(row.node,col.node,sep='_')]
sum(S$Lineages$rc \%in\% dm$Lineages$rc)/nrow(S$Lineages)      ### Probability of a true rc being ID'd
sum(dm$Lineages$rc \%in\% S$Lineages$rc)/nrow(dm$Lineages)     ### Probability of ID'd rc being true positive
}
